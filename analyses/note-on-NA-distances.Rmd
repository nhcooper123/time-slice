---
title: "Note on NAs in distance matrices"
author: "Thomas Guillerme"
date: "`r Sys.Date()`"
output:
  html_document:
    fig_width: 12
    fig_height: 6
---

# Quick note on the NAs in distance matrices

```{r}
library(Claddis)
library(dispRity)
```

These NAs come from taxa having no overlapping data.
Because we're using a Gower distance, data is not imputed when missing (c.f. Generalised Euclidean Distance or other methods that replace NA by the mean).
The solution is to use a Generalised Euclidean Distance or to remove the problematic taxa.

## Using Generalised Euclidean Distances-ish

This solution is the easiest and don't generate any loss in data.
It's not exactly equivalent to the GED described in Graeme's `?MorphDistMatrix` (or `MorphDistMatrixFast` - same but faster) which replaces NAs by the mean values _during_ the distance matrix calculation.
With this trick, the proper distance type is used (i.e. GED, Gower, etc...) and the mean of these distances is used as a replacement value.
In other words, when the distance between two taxa is incalculable, this trick assume that the distance is average.

This "compactise" the morphospace by adding more "average" shapes in it.
Not a big problem when there are a couple of incomparable taxa, a bit more (much more?) when there are many.

The trick goes like (for example, on the Brusatte one):

```{r}
slug <- "Brusatte2014"

## Getting the distance matrix
matrix_dist <- readRDS(paste0("../data/processed/distance_matrix.", slug ,".Rda"))
any(is.na(matrix_dist))

## Replacing them by the mean
matrix_dist <- ifelse(!is.na(matrix_dist), matrix_dist, mean(matrix_dist, na.rm = TRUE))
any(is.na(matrix_dist))
dim(matrix_dist)
```

## Trimming the morphological matrix

This method consists in removing the taxa with non-overlap morphological character _prior_ to the distance analysis.
We can either go brutally using Graeme's `TrimMorphDistMatrix` function:

```{r}
## Getting the distance matrix
matrix_dist <- readRDS(paste0("../data/processed/distance_matrix.", slug ,".Rda"))

## Matrix dimensions before trimming
dim(matrix_dist)

## Trimming the distance matrix
trimming <- TrimMorphDistMatrix(matrix_dist)
matrix_dist <- trimming$dist.matrix
any(is.na(matrix_dist))

## Matrix dimensions after trimming
dim(matrix_dist) # -19 taxa
as.vector(trimming$removed.taxa)
```

The other solution is to remove the problematic taxa before the distance calculation using the `SafeTaxonomicReduction` function.
This should go with the following algorithm:
  
  1. Remove the _m1_ taxa with no overlapping discrete character resulting in a matrix of (_n_ - _m1_) rows
  2. Run ancestral states reconstruction resulting in a matrix of ((_n_ - _m1_) + (_n_ - _m1_ - 1)) rows (if tree is fully binary)
  3. Calculate pairwise distances of size ((_n_ - _m1_) + (_n_ - _m1_ - 1))

However, because we're using a really safe ancestral states reconstruction method (i.e. only keep reconstruction with a scaled likelihood > 0.95), step 3. is still likely to generate NAs.
We thus need to run a while loop until the step 3. generates no NAs.
This will go like:

  4. Return to step 1 and with _m1_ =  _m1_ + _m2_ with _m2_ being the taxa contributing to NAs in step 3.

This is likely to result in a matrix with really few taxa.

## Differences

In the end, although the GEDish method will generate shittier morphopsaces with increasing missing data than a proper trimming method (Graeme have shown that at least when talking about NAs in the morphological matrix; c.f. the distance matrix); I think it's not a huge problem compared with how the distances are calculated in general.
In fact, using the `MorphDistMatrix` completely ignores inapplicable data (and treats them as NAs), this probably "compactise" the morphospace as well since one could argue that an inapplicable data should create negative multidimensional axis (for example on Gavin's beak PCO duck axis, species with no beaks should be stored a neither end of this axis but probably perpendicularly to it).
But that's an entire new field of pain that I'm just slowly coming out from so let's skip it.

Long story short: method one is quick and easy; method two is more correct but reduces the amount of data (and is not totally correct either).