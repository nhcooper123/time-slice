---
title: "Time slice analyses"
author: "Natalie Cooper and Thomas Guillerme"
date: "`r Sys.Date()`"
output:
  html_document:
    fig_width: 6
    fig_height: 6
---

TITLE?
===============

DETAILS
This code loads the data and extracts matrices and other files needed to run the analyses in the paper. Note that these analyses can take time, so we save the outputs to a `data/backups` folder and use these in other `.Rmd` files so that the analyses can be replicated more quickly. Below we lay out the process in detail for one dataset, and then provide the code for the other datasets below this.

```{r}
set.seed(123)
```

Load packages
-----------------------------------

Make sure you work with `dispRity` 0.4 and TG's version of `Claddis` (much faster than GL's).

```{r, eval = TRUE}
# The latest version of devtools and ape
library(devtools)
library(ape)

## The latest version of Claddis (on development on my own branch)
if(!require(Claddis)) install_github("TGuillerme/Claddis")
library(Claddis)

## The latest version of dispRity 
if(!require(dispRity)) install_github("TGuillerme/dispRity", ref = "master")
library(dispRity) 
```
<!-- TG: I've switched to master branch for the new functions -->

Loading the data
-----------------------------------

To run `dispRity` analyses we need the **morphospace**, the **phylogeny** (with a root age and node labels) and the **first and last occurrence dates** (FADLAD). The tree and FADLAD are in the `data/` folder. To construct the morphospace we need to use the `distance_matrix` files we created in `01-extract-data-for analyses.Rmd` and stored in `data/processed`.

```{r}
## Choose a slug
slug <- "Beck2014"

## Loading the discrete morphological matrix
## This is just to match the names with the tree
matrix <- ReadMorphNexus(paste0("../data/matrices/", slug, ".nex"))

## Loading the FADLAD
FADLAD <- read.csv(paste0("../data/FADLAD/", slug, ".csv"), row.names = 1, header = TRUE)

## Loading the tree
tree <- read.nexus(paste0("../data/trees/", slug, ".tre"))
## Adding node labels and a root age (max tree age date)
tree <- makeNodeLabel(tree, method = "number", prefix = "n")
tree$root.time <- max(tree.age(tree)[, 1])

## Cleaning the tree to remove things that aren't in the matrix 
cleaned_data <- clean.data(matrix$matrix, tree)
matrix$matrix <- cleaned_data$matrix
tree <- cleaned_data$tree

## Loading the distance matrices
## See "01-extract-data-for analyses.Rmd" for how we made these
load(paste0("../data/processed/distance_matrix.", slug ,".Rda"))

## Ordinating the matrix
morphospace <- cmdscale(matrix_dist, k = nrow(matrix_dist) - 2, add = TRUE)$points

```


Stratigraphy
-----------------------------------

How to go about that????
Need to collate data ourselves or can we use strap?
<!-- TG: got all that covered with the new get.bin.ages function! -->

```{r}
## Get the stratigraphic ages
time_ages <- get.bin.ages(tree, type = "Age")

## Get the stratigraphic ages
time_epoch <- get.bin.ages(tree, type = "Epoch")

## Get the median age duration (to create equal time bins)
age_duration <- median(abs(diff(time_ages)))

## Get the number of ages (to create equal time bins)
age_length <- length(time_ages)

## Get the median epoch duration (to create equal time bins)
epoch_duration <- median(abs(diff(time_epoch)))

## Get the number of epochs (to create equal time bins)
epoch_length <- length(time_epoch)
```

With this data, I suggest we can explore these different scenarios:

Name | Type | Scenario | Based on
------------|----------|----------
un_bin_age  | unequal bins | stratigraphic ages | Ages durations
un_bin_epo  | unequal bins | stratigraphic epochs | Epoch durations
eq_bin_age_med  | equal bins   | median age bins | Median age duration
eq_bin_epo_med  | equal bins   | median epoch bins | Median epoch duration
eq_bin_age_len  | equal bins   | number of age bins | same number of ages but equal duration
eq_bin_epo_len  | equal bins   | number epoch bins | same number of epoch but equal duration
slice_age_med  | time slicing | median age slices | median age duration (+ our 4 "models" of evolution)
slice_epo_med  | time slicing | median epoch slices| median epoch duration (+ our 4 "models" of evolution)
slice_age_len  | time slicing | number of age slices | same number of ages but slices (+ our 4 "models" of evolution)
slice_epo_len  | time slicing | number of epoch slices | same number of epoch but slices (+ our 4 "models" of evolution)

What do you think?


```{r, eval = FALSE}

## Run the function for Beck data

slug <- "BeckLee"
metric <- c(sum, variances)
metric.name <- "sumvar"

for (bins in seq_along(c(5,10,15,20))){
 run.all.sims(morphospace, tree, FADLAD, bins, metric, 
              metric.name, inc.nodes = TRUE, slug)
}

slug <- "BeckLee"
metric <- c(median, centroids)
metric.name <- "medcentroid"

for (bins in seq_along(c(5,10,15,20))){
 run.all.sims(morphospace, tree, FADLAD, bins, metric, 
              metric.name, inc.nodes = TRUE, slug)
}

```

<!-- TG: Suggestion for a "testing the effect of binning/slicing" pipeline -->


```{r, eval = FALSE}

## Run the function for Beck data

slug <- "BeckLee"
metric <- c(sum, variances)
metric.name <- "sumvar"

for (bins in seq_along(c(5,10,15,20))){
 run.all.sims(morphospace, tree, FADLAD, bins, metric, 
              metric.name, inc.nodes = TRUE, slug)
}

slug <- "BeckLee"
metric <- c(median, centroids)
metric.name <- "medcentroid"

for (bins in seq_along(c(5,10,15,20))){
 run.all.sims(morphospace, tree, FADLAD, bins, metric, 
              metric.name, inc.nodes = TRUE, slug)
}

```                      




